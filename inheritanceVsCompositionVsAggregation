## Наследование vs Композиция vs Агрегация

Между двумя классами/объектами существует разные типы отношений. Самым базовым типом отношений является ассоциация (*association*), 
это означает, что два класса как-то связаны между собой, и мы пока не знаем точно, в чем эта связь выражена и собираемся уточнить ее в будущем.
Обычно это отношение используется на ранних этапах дизайна, чтобы показать существующую зависимость между классами.

Более точным типом отношений является отношение *открытого наследования* (отношение «является», IS A Relationship),
которое говорит, что все, что справедливо для базового класса справедливо и для его наследника. 
Именно с его помощью мы получаем полиморфное поведение, абстрагируемся от конкретной реализации классов, 
имея дело лишь с абстракциями (интерфейсами или базовыми классами) и не обращаем внимание на детали реализации.

И хотя наследование является отличным инструментом, его явно недостаточно для решения всех типов задач.
Во-первых, далеко не все отношения между классами определяются отношением «является», а во-вторых,
наследование является самой сильной связью между двумя классами, которую невозможно разорвать во время исполнения.

В этом случае нам на помощь приходит другая пара отношений: композиция (**composition**) и агрегация (**aggregation**).
Оба они моделируют отношение «является частью» (HAS-A Relationship) и обычно выражаются в том,
что класс целого содержит поля (или свойства) своих составных частей. Грань между ними достаточно тонкая,
но важная, особенно в контексте управления зависимостями.

Разница между композицией и агрегацией заключается в том, что **в случае композиции целое явно контролирует время жизни своей составной части**
(часть не существует без целого), а **в случае агрегации целое хоть и содержит свою составную часть, время их жизни не связано**
(например, составная часть передается через параметры конструктора).

CompositeCustomService для управления своими составными частями использует композицию, а AggregatedCustomService – агрегацию.
При этом явный контроль времени жизни обычно приводит к более высокой связанности между целым и частью, поскольку используется конкретный тип,
тесно связывающий участников между собой.

задачу с сервисами и репозитариями можно решить как с помощью наследования, так и с помощью агрегации. Каждый вариант
приводит к одному и тому же конечному результату, при этом связанность изменяется от очень высокой (при наследовании)
к очень слабой (при агрегации).

В большинстве случаев следует предпочесть агрегацию наследованию, поскольку первая дает большую гибкость и динамичность во время исполнения.
